#!/usr/bin/env bash

source ~/.oh-my-zsh/custom/plugins/zsh-git-fzf/src/helpers
source ~/.oh-my-zsh/custom/plugins/zsh-git-fzf/src/completions

local FZF_OPTIONS="--no-preview"

_worktree_help() {
    local PREFIX="git-fzf worktree"
    echo "Worktree Usage:"
    echo -e "\t${PREFIX} list: List details of each working tree. Press ESC to exit or select a worktree to move into it"
    echo -e "\t${PREFIX} prune: Prune working tree information"
    echo -e "\t${PREFIX} fetch: Fetch branches from the bare repository"
    echo -e "\t${PREFIX} add [new-branch] [remote-branch(optional)]: Create new working tree"
    echo -e "\t${PREFIX} remove: Remove a working tree"
    echo -e "\t${PREFIX} clean: Remove all working trees that do not have a corresponding remote branch"
}

_worktree_list() {
    local WORKTREE=$(git worktree list | fzf $FZF_OPTIONS)

    # if the use exited fzf without choosing a worktree
    [ -z $WORKTREE ] && return 0

    local WORKTREE_PATH=$(echo $WORKTREE | awk '{print $1;}')
    local WORKTREE_COMMIT=$(echo $WORKTREE | awk '{print $2;}')
    local WORKTREE_BRANCH=$(echo $WORKTREE | awk '{print $3;}')

    pushd $WORKTREE_PATH > /dev/null
}

_worktree_prune() {
    git worktree prune
}

_worktree_remove() {
    local WORKTREE=$(git worktree list | fzf $FZF_OPTIONS)

    # if the use exited fzf without choosing a worktree
    [ -z $WORKTREE ] && return 0

    local HOLD_PATH=$PWD
    local WORKTREE_PATH=$(echo $WORKTREE | awk '{print $1;}')
    local WORKTREE_BRANCH=$(basename $WORKTREE_PATH)

    [ $HOLD_PATH = $WORKTREE_PATH ] && _move_to_bare_repo

    local WORKTREE_REMOVE_OUTPUT=$(git worktree remove $WORKTREE_BRANCH 2>&1)

    # if the worktree was removed successfully => prune and return
    [ -z $WORKTREE_REMOVE_OUTPUT ] && _worktree_prune && colorful_echo "Worktree named '$WORKTREE_BRANCH' was removed successfully" && return 0

    colorful_echo $WORKTREE_REMOVE_OUTPUT "RED"

    local UNTRACKED_OR_MODIFIED_FILES="fatal: '$WORKTREE_BRANCH' contains modified or untracked files, use --force to delete it"

    if [ $WORKTREE_REMOVE_OUTPUT != $UNTRACKED_OR_MODIFIED_FILES ]; then
        pushd $HOLD_PATH > /dev/null
        return 0
    fi

    read "response?Force delete? [Y/n]"
    response=${response:l} #tolower
    if [[ $response =~ ^(yes|y| ) ]] || [[ -z $response ]]; then
        git worktree remove -f $WORKTREE_BRANCH
        _worktree_prune
        return 0
    fi

    pushd $HOLD_PATH > /dev/null
}

_exists_remote_repository() {
    local BRANCH=$1
    local WORKTREE_EXISTS=$(eval git ls-remote origin $BRANCH)
    if [ ! -z $WORKTREE_EXISTS ]
    then
        echo "true"
    else
        echo "false"
    fi
}

_worktree_add() {
    if [[ $# -ne 1 ]] && [[ $# -ne 2 ]]; then
        colorful_echo "Illegal number of parameters" "RED"
        return 1
    fi

    local HOLD_PATH=$PWD
    local BRANCH_NAME=$1
    local REMOTE_BRANCH_NAME=$2

    local WORKTREE_EXISTS=$(_exists_worktree $BRANCH_NAME)
    if [ $WORKTREE_EXISTS = "true" ]; then
        colorful_echo "Worktree named already exists: '$BRANCH_NAME'" "RED"
        return 1
    fi

    if ! _move_to_bare_repo; then
        pushd $HOLD_PATH > /dev/null
        return 1
    fi

    _bare_repo_fetch

    local BARE_REPO_PATH=$PWD
    local NEW_WORKTREE_PATH=$BARE_REPO_PATH/$BRANCH_NAME

    local WORKTREE=""
    [[ $# -eq 1 ]] && WORKTREE=$(git worktree list | fzf $FZF_OPTIONS)

    local BRANCH_EXISTS=$(_exists_remote_repository $BRANCH_NAME)

    if [[ $# -eq 1 ]]; then
        # if the use exited fzf without choosing a worktree, this means that the we want to clone a remote branch
        if [[ -z $WORKTREE ]]; then
            if [ $BRANCH_EXISTS = "false" ]; then
                colorful_echo "Remote branch named: '$BRANCH_NAME' does not exist" "RED"
                pushd $HOLD_PATH > /dev/null
                return 1
            fi
            colorful_echo "Creating worktree from remote branch"
            git worktree add $NEW_WORKTREE_PATH
            git branch --set-upstream-to=origin/$BRANCH_NAME $BRANCH_NAME
            pushd $NEW_WORKTREE_PATH > /dev/null
            git pull
        else
            # otherwise create a worktree from a local branch

            if [ $BRANCH_EXISTS = "true" ]; then
                colorful_echo "Remote branch named: '$BRANCH_NAME' already exists" "RED"
                return 1
            fi

            colorful_echo "Creating worktree from local branch"

            local WORKTREE_PATH=$(echo $WORKTREE | awk '{print $1;}')

            pushd $WORKTREE_PATH > /dev/null

            git worktree add -b $BRANCH_NAME $NEW_WORKTREE_PATH
            git push --set-upstream origin $BRANCH_NAME
        fi
    fi

    if [[ ! -z $REMOTE_BRANCH_NAME ]] && [[ $# -eq 2 ]]; then
        if [ $BRANCH_EXISTS = "true" ]; then
            colorful_echo "Remote branch named: '$BRANCH_NAME' already exists" "RED"
            pushd $HOLD_PATH > /dev/null
            return 1
        fi

        local REMOTE_BRANCH_EXISTS=$(_exists_remote_repository $REMOTE_BRANCH_NAME)
        if [ $REMOTE_BRANCH_EXISTS = "false" ]; then
            colorful_echo "Remote branch named: '$REMOTE_BRANCH_NAME' does not exist" "RED"
            pushd $HOLD_PATH > /dev/null
            return 1
        fi
        colorful_echo "Creating worktree from remote branch"
        git worktree add --track -b $BRANCH_NAME $NEW_WORKTREE_PATH origin/$REMOTE_BRANCH_NAME
        git push --set-upstream origin $BRANCH_NAME
    fi

    # if there is an installation script, execute it
    # TODO pass installation script as an argument(absolute path?)
    # Is there a git hook for this process?
    if [ -f $NEW_WORKTREE_PATH/install ]; then
        chmod +x $NEW_WORKTREE_PATH/install
        $NEW_WORKTREE_PATH/install
    fi

    # if there is a custom editor, open the worktree
    # TODO edge case for vim, which is a terminal editor
    # Do I actualy need this?? Maybe this command can be included in the installation script!?!
    # if [ ! -z $EDITOR ]
    # then
    #     eval $EDITOR $NEW_WORKTREE_PATH
    #     return 0
    # fi

    # otherwise move into the worktree
    pushd $NEW_WORKTREE_PATH > /dev/null
}

_exists_worktree() {
    local WORKTREE=$1
    local COMMAND="git worktree list | awk '{print \$3;}' | awk '/\[$WORKTREE\]/{print \$1}'"
    local WORKTREE_FOUND=$(eval $COMMAND)

    if [ ! -z $WORKTREE_FOUND ]; then
        echo "true"
    else
        echo "false"
    fi
}

_worktree_fetch() {
    local HOLD_PATH=$PWD

    if ! _move_to_bare_repo; then
        pushd $HOLD_PATH > /dev/null
        return 1
    fi

    _bare_repo_fetch

    pushd $HOLD_PATH > /dev/null
}

# TODO: is there a better way to implement this??
_remove_local_that_do_not_exist_on_remote_repository() {
    git remote update --prune > /dev/null
    git branch -vv | awk '/: gone]/{print $1}' | awk '!/^(*|+)/' | xargs --no-run-if-empty git branch -d > /dev/null
}

_bare_repo_fetch() {
    local REMOTE_ORIGIN_FETCH=$(git config remote.origin.fetch)
    if [ -z $REMOTE_ORIGIN_FETCH ] || [ $REMOTE_ORIGIN_FETCH != "+refs/heads/*:refs/remotes/origin/*" ]; then
        git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
    fi
    _remove_local_that_do_not_exist_on_remote_repository
    git fetch --all --prune > /dev/null
}

# TODO: is there a better way to implement this??
_move_to_bare_repo() {
    local BARE_REPO_PATH=$(eval git worktree list | awk '/\(bare\)/{print $1}')

    [ -z $BARE_REPO_PATH ] && colorful_echo "Bare repository does not exist" "RED" > /dev/stderr && return 1

    # colorful_echo "Found bare repository: $BARE_REPO_PATH"
    pushd $BARE_REPO_PATH > /dev/null
    return 0
}

_worktree_clean() {
    # awk '$3{print $3}!$3{print "(bare)"}' => there is not a 3rd column in bare repo, so we return (bare)
    # sed 's:^.\(.*\).$:\1:' => remove first and last character(e.g. [master] => master)
    local BRANCHES_NAMES=$(git worktree list | awk '$3{print $3}!$3{print "(bare)"}' | sed 's:^.\(.*\).$:\1:')

    local BRANCHES=()
    while read -r branch_name
    do
        BRANCHES+=("$branch_name")
    done <<< "$BRANCHES_NAMES"

    local BRANCHED_TO_BE_REMOVED=()
    for branch in $BRANCHES; do
        [[ $branch = "bare" ]] && continue

        local BRANCH_EXISTS=$(_exists_remote_repository $branch)
        [ $BRANCH_EXISTS = "true" ] && continue

        BRANCHED_TO_BE_REMOVED+=($branch)
    done

    [ ${#BRANCHED_TO_BE_REMOVED[@]} -eq 0 ] && colorful_echo "All worktrees have a corresponding remote branch" && return 0

    for branch in $BRANCHED_TO_BE_REMOVED; do
        local WORKTREE_REMOVE_OUTPUT=$(git worktree remove $branch 2>&1)

        # if the worktree was removed successfully => prune and return
        [ -z $WORKTREE_REMOVE_OUTPUT ] && colorful_echo "Worktree named '$branch' was removed successfully" && continue

        colorful_echo "Worktree named '$branch' was not removed successfully" "RED"
        colorful_echo $WORKTREE_REMOVE_OUTPUT "RED"
    done

    _worktree_prune
}

_worktree() {
    if ! hash fzf 2>/dev/null; then
        colorful_echo "You need to install fzf: https://github.com/junegunn/fzf" "RED"
        return 1
    fi

    local OPERATION=$1
    [ -z $OPERATION ] && _worktree_help && return 0

    local IS_GIT_REPOSITORY="$(git rev-parse --is-inside-work-tree 2>/dev/null)"
    if [[ ! $IS_GIT_REPOSITORY ]]; then
        colorful_echo "You need to be inside a git repository" "RED"
        return 1
    fi

    if [ $OPERATION = "list" ]; then
        _worktree_list
    elif [ $OPERATION = "prune" ]; then
        _worktree_prune
    elif [ $OPERATION = "fetch" ]; then
        _worktree_fetch
    elif [ $OPERATION = "add" ]; then
        _worktree_add ${@:2} # pass all arguments except the first one(add)
    elif [ $OPERATION = "remove" ]; then
        _worktree_remove
    elif [ $OPERATION = "clean" ]; then
        _worktree_clean
    else
        _worktree_help
    fi
}
